---
title: "Plotting models with confidence (intervals)"
author: "Sam vanDeurs samantha.vandeurs@usys.ethz.ch"
date: "2023-09-15"
output: html_document
---
#lab retreat 2023

```{r}

library(lmerTest)
library(ggplot2)
library(Rmisc)
```

**This chunk of code can be converted into a function in the future, however I will proceed here with the hardcoded variables.**

Days_to_flowering: a continuous numeric and our response variable
precip.wettest.month: a continuous numeric and one of our fixed effects
Cohort: a factor with two levels (1976 and 2020) and one of our fixed effects
Treatment: a factor with two levels (Control and drought) and one of our fixed efects
Block: a factor with ten levels and a random effect
Population.1: a factor with 21 levels and a random effect
Load in the data and set the variables to the correct class for the model and plot. 

```{r}
#read in data
data<-read.csv("/Users/Magnolia/lactuca_model_example.csv")# change to your location
data$Treatment<-as.factor(data$Treatment) # set to factor
data$Cohort<-as.factor(data$Cohort) # set to factor
data$Block<-as.factor(data$Block) # set to factor
data$Days_to_flowering<-as.numeric(data$Days_to_flowering) # Set to numeric
data$Precipitation.of.Wettest.Month<-as.numeric(data$Precipitation.of.Wettest.Month) # set to numeric
```

We can make mixed models of days to flowering by precipiation of the wettest month, cohort and treatment.

```{r}
# make  model
mod1 <- lmer(Days_to_flowering~ Precipitation.of.Wettest.Month + Cohort +Treatment + (1|Block)+  (1|Population.1), data = data)

#get the significance
anova(mod1)

#get the population means for plotting
data_summary <- summarySE(data=data, measurevar = "Days_to_flowering", groupvars = c("Population.1", "Cohort","Precipitation.of.Wettest.Month","Treatment"))

#assign colors to factors 
col_years<-c("1976"="#627715","2020"="#F7A60F")
col_treat<-c("Drought"="#BC5707","Control"="#3B602F")

#plot the model
smooth.cohort.facet <- ggplot(data_summary, aes(x=Precipitation.of.Wettest.Month, y=Days_to_flowering, colour=Treatment, group=Treatment, label=Population.1))+ 
  #add error bars for population mean
  geom_errorbar(aes(colour=Treatment,ymin=Days_to_flowering-se, ymax=Days_to_flowering+se), width=.1) +
  #edit size of points
  geom_point(size=3)+
  #Add labels
  xlab("Precipitation of the wettest month (mm)") + ylab("Days to flowering")+
  #Fit the model
  geom_smooth(aes(color = Treatment, fill = Treatment),method = "lm", formula=y ~ x )+
  #Set the colors
  scale_color_manual(values=col_treat)+
  #set the fills
  scale_fill_manual(values=col_treat) +
  #separate by cohort
  facet_wrap(~Cohort)+
#add the significance text
  annotate("text", x=75, y=210, label= "Cohort 0.011* \n Treatment <0.001*** \n Precip 0.0098**" ,size = 3)+
  #set the plot theme
  theme_classic()
smooth.cohort.facet

smooth.treatment.facet <- ggplot(data_summary, aes(x=Precipitation.of.Wettest.Month, y=Days_to_flowering, colour=Cohort, group=Cohort, label=Population.1))+ 
  geom_errorbar(aes(colour=Cohort,ymin=Days_to_flowering-se, ymax=Days_to_flowering+se), width=.1) +
  geom_point(size=3)+
  #geom_point(position=pd, size=3)+
  xlab("Precipitation of the wettest month (mm)") + ylab("Scaled fitness (Total seed mass)")+
  geom_smooth(aes(color = Cohort, fill = Cohort),method = "lm", formula=y ~ x )+
  scale_color_manual(values=col_years)+
  scale_fill_manual(values=col_years) +
  facet_wrap(~Treatment)+
#facet_grid(vars(Treatment), vars(group))+
  annotate("text", x=75, y=210, label= "Cohort 0.011* \n Treatment <0.001*** \n Precip 0.0098**" ,size = 3)+
  theme_classic()
smooth.treatment.facet
```

However, the line plotted here is the linear model generated by geom_smooth of the data plotted, in this case the population means, and does not represent the model we spent all this time perfecting and selecting for the entire data set. 


**Code requires changes with the variable you plan to plot along the X axis (in this case Precipitation.of.Wettest.Month).**

We need to plot the line that represents the actual model, which means generating the predictive points of the model. 


```{r, echo=FALSE,message=FALSE, warning=F}
#We first need to generate a dataframe with x values for which we could like to predict y-values. The more x-values, the more y values and therefore smoother your final plotted model might be. Here Is divide my range of values into 100 points and populate the dataframe with my other variables. 

data_df <- expand.grid(
  Precipitation.of.Wettest.Month = seq(min(data$Precipitation.of.Wettest.Month), max(data$Precipitation.of.Wettest.Month), by = c((max(data$Precipitation.of.Wettest.Month)-min(data$Precipitation.of.Wettest.Month))/100)),
  Cohort = unique(data$Cohort),
  Block = unique(data$Block),
  Treatment = unique(data$Treatment),
  Population.1 = unique(data$Population.1)
)
#Then I predict the response variable usign the model I generated above (mod1) with the random effects included (re.form = NULL)
data_df$Days_to_flowering <- predict(mod1, 
                                             newdata = data_df, 
                                             re.form = NA)
# I then order the dataframe by the x-axis variable to ensure proper plotting data the line (otherwise it may plot the x-varaible not in the correct order and result in jagged lines)  
data_df <- data_df[order(data_df$Cohort, data_df$Precipitation.of.Wettest.Month), ]


# Define a bootstrapping function. This function takes in a mixed model and a dataset, 
# and returns predictions based on resampled random effects. This helps in estimating the variability in predictions for the confidence interval. 

boot_fn <- function(model, newdata) {
    # Extracting fixed effects and random effects from the model.
    beta <- fixef(model)
    b <- ranef(model)
    
    # Resampling from the random effects.
    b_samples <- lapply(b, function(x) {
        x[sample(1:nrow(x), size = nrow(x), replace = TRUE), , drop = FALSE]
    })
    
    # Combining fixed and resampled random effects.
    combined_effects <- c(beta, unlist(b_samples))
    
    # Generating predictions based on the combined effects.
    preds <- predict(model, newdata = newdata, re.form = NA, allow.new.levels = TRUE)
    
    return(preds)
}

# Setting a seed ensures reproducibility data the bootstrapping results.
set.seed(123)

# Performing bootstrapping using the 'boot_fn' function and the 'mod1' model. 
#This can take some time, you can try playing the number data sims, 1000 (the original value) is high
bs <- bootMer(mod1, FUN=function(x) boot_fn(x, data_df), nsim=100)

# Extracting predictions from bootstrapped results.
bs_preds <- bs$t

# Calculating the lower 2.5% and upper 97.5% percentiles for the bootstrapped predictions, providing a 95% confidence interval.
data_df$lwr <- apply(bs_preds, 2, function(x) quantile(x, probs=0.025))
data_df$upr <- apply(bs_preds, 2, function(x) quantile(x, probs=0.975))

# Creating a sequence data 'Precipitation.of.Wettest.Month' values for smoothing.
precip_seq <- seq(min(data_df$Precipitation.of.Wettest.Month), max(data_df$Precipitation.of.Wettest.Month), length.out = length(unique(data_df$Precipitation.of.Wettest.Month)))

# Initializing an empty dataframe to store smoothed data.
data_df_smoothed <- data.frame()

# Looping through each combination data factor for 'Cohort' and 'Treatment' to generate smoothed curves.As the points are decretely generated for 
for (cohort in c("1976", "2020")) {
  for (treatment in c("Control", "Drought")) {
    
    # Subsetting data for the current combination data 'Cohort' and 'Treatment'.
    subset_data <- data_df[data_df$Cohort == cohort & data_df$Treatment == treatment, ]
    
    # Fitting a LOESS model for the main effect.
    fit <- loess(Days_to_flowering ~ Precipitation.of.Wettest.Month, data = subset_data)
    
    # Predicting smoothed values using the LOESS model.
    smoothed_vals <- predict(fit, newdata = data.frame(Precipitation.of.Wettest.Month = precip_seq))
    
    # Fitting LOESS models for the lower and upper bounds data the confidence intervals.
    fit_lwr <- loess(lwr ~ Precipitation.of.Wettest.Month, data = subset_data)
    fit_upr <- loess(upr ~ Precipitation.of.Wettest.Month, data = subset_data)
    
    # Predicting smoothed confidence interval values.
    smoothed_lwr <- predict(fit_lwr, newdata = data.frame(Precipitation.of.Wettest.Month = precip_seq))
    smoothed_upr <- predict(fit_upr, newdata = data.frame(Precipitation.of.Wettest.Month = precip_seq))
    
    # Combining the smoothed data for the current combination.
    smoothed_subset <- data.frame(
      Precipitation.of.Wettest.Month = precip_seq,
      Cohort = cohort,
      Treatment = treatment,
      Days_to_flowering = smoothed_vals,
      lwr = smoothed_lwr,
      upr = smoothed_upr
    )
    
    # Appending the smoothed data to the main dataframe.
    data_df_smoothed <- rbind(data_df_smoothed, smoothed_subset)
  }
}


```

```{r}
data_summary <- summarySE(data=data, measurevar = "Days_to_flowering", groupvars = c("Population.1", "Cohort","Precipitation.of.Wettest.Month","Treatment"))

model_cohort_facet<-ggplot(data_summary, aes(x=Precipitation.of.Wettest.Month, y=Days_to_flowering, colour=Treatment, group=Treatment)) + 
  geom_errorbar(aes(colour=Treatment,ymin=Days_to_flowering-se, ymax=Days_to_flowering+se), width=.1) +
  geom_point( size=3)+
  xlab("Precipitation of the wettest month (mm) [decadal mean]") + ylab("Days to flowering")+
geom_line(data = data_df_smoothed, aes(x=Precipitation.of.Wettest.Month, y=Days_to_flowering, 
                               colour=Treatment, group=interaction(Cohort, Treatment))) +
  geom_ribbon(data = data_df_smoothed, aes(x=Precipitation.of.Wettest.Month, ymin=lwr, ymax=upr, fill=Treatment), alpha=0.3, color=NA) +
  facet_wrap(~Cohort)+
    scale_color_manual(values=col_treat)+
  scale_fill_manual(values=col_treat) +
   annotate("text", x=100, y=210, label= "Cohort: <0.011* \n Treatment: <0.001*** \n PWM: 0.0098**",size = 3)+
  theme_classic()
model_cohort_facet

model_treat_facet<-ggplot(data_summary, aes(x=Precipitation.of.Wettest.Month, y=Days_to_flowering, colour=Cohort, group=Cohort)) + 
  geom_errorbar(aes(colour=Cohort,ymin=Days_to_flowering-se, ymax=Days_to_flowering+se), width=.1) +
  geom_point( size=3)+
  xlab("Precipitation of the wettest month (mm) [decadal mean]") + ylab("Days to flowering")+
geom_line(data = data_df_smoothed, aes(x=Precipitation.of.Wettest.Month, y=Days_to_flowering, 
                               colour=Cohort, group=interaction(Cohort, Treatment))) +
  geom_ribbon(data = data_df_smoothed, aes(x=Precipitation.of.Wettest.Month, ymin=lwr, ymax=upr, fill=Cohort), alpha=0.3, color=NA) +
  facet_wrap(~Treatment)+
    scale_color_manual(values=col_years)+
  scale_fill_manual(values=col_years) +
   annotate("text", x=100, y=210, label= "Cohort: <0.011* \n Treatment: <0.001*** \n PWM: 0.0098**",size = 3)+
  theme_classic()
model_treat_facet
```

and for comparison the original plots

```{r}
# Plot of the 
smooth.cohort.facet
#
model_cohort_facet


#
smooth.treatment.facet
#
model_treat_facet
```


While the differences in this examples are slight, in other cases the differences will be more noticeable. For example, here we have seed number data. The top image is data plotted in ggplot, and then fit with geom_smooth as above.


```{r , echo=FALSE, fig.cap="geom_smooth fit a line thorugh the means of my plotted data", out.width = '50%'}
knitr::include_graphics("smooth fit.png")
```



And here we are plotting the actual model with the calculated 95% confidence intervals



```{r , echo=FALSE, fig.cap="the plotted line is the model that we made, with the populaiton means plotted on top with the 95% confidence interval ", out.width = '50%'}
knitr::include_graphics("model_fit.png")
```

What we plot can impact how we interpret the trends in our data. 